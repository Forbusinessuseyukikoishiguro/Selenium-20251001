

Xpath　CSS階層　チートシート　note記事にしてレイアウト崩れないようにLEVEL上げ


Xpath Vs CSS Selector in Java - GeeksforGeeks
noteに投稿することを想定して、XPathとCSSセレクターの階層指定について、見やすくまとめた記事見出しやテーブル、コードブロックを使い、レイアウトが崩れず理解しやすいようにレベルアップさせた構成です。
【速習】Webスクレイピングの必須知識：XPathとCSSセレクター階層指定チートシート
Webスクレイピングを始めたばかりのとき、「この要素、どうやって指定すればいいの？」と悩むことはありませんか？
複雑な階層を持つWebページから目的のデータを効率よく抽出するには、XPathとCSSセレクターの使い分けが鍵となります。
この記事では、見慣れないHTML構造に直面しても迷わないよう、階層指定に特化したチートシートをまとめました。
XPathとCSSセレクター、どっちを使うべき？
特徴	XPath	CSSセレクター
複雑な階層	親要素への移動（上方向）が可能。兄弟要素の指定も柔軟。	子孫要素への移動（下方向）が基本。隣接・一般兄弟要素の指定も可能。
テキスト	要素内のテキスト内容で指定可能。	テキスト内容での指定は不可。
速度	CSSセレクターに比べ、複雑なクエリでは若干遅くなることがある。	一般的に高速。
習得難易度	機能が豊富な分、文法がやや複雑。	CSSの知識があれば直感的に理解しやすい。
使い分け	複雑な階層 や テキスト指定 が必要な場合に。	高速性 が求められる場合や、ID・クラスが明確な場合に。
XPath：複雑な階層を自由自在にたどる
XPathは、ディレクトリパスのように階層をたどることで要素を特定します。特に、現在位置から親要素へ移動できる点が強力です。
基本の階層指定
指定方法	説明	例
//	ドキュメント内のどこからでも、子孫要素を検索します。	//div （すべての <div> 要素）
/	直下の子要素を指定します。	/html/body/div （<body>の直下の <div>）
.. または parent::*	親要素に移動します。	//span[@id='target']/..
兄弟要素の指定
指定方法	説明	例
preceding-sibling::*	同じ親を持つ先行する兄弟要素をすべて選択します。	//div[@class='item']/preceding-sibling::h2
following-sibling::*	同じ親を持つ後続する兄弟要素をすべて選択します。	//h2/following-sibling::p
属性・テキストによる指定
指定方法	説明	例
[@attribute='value']	属性値が完全に一致する要素。	//a[@href='https://example.com']
[contains(@attribute, 'value')]	属性値に特定の文字列を含む要素。	//div[contains(@class, 'card')]
[text()='テキスト']	テキスト内容が一致する要素。	//button[text()='検索']
CSSセレクター：シンプルで高速な階層指定
CSSセレクターは、主に下方向への階層指定に優れており、高速で可読性が高いのが特徴です。
基本の階層指定
指定方法	説明	例
（スペース）	子孫セレクター。指定要素のすべての子孫要素を検索します。	#main p （IDがmainの要素内にあるすべての <p>）
>	子セレクター。指定要素の直下の子要素を指定します。	.parent > li （クラスがparentの直下の <li>）
兄弟要素の指定
指定方法	説明	例
+	隣接兄弟セレクター。指定要素の直後に来る兄弟要素を指定します。	h2 + p （<h2>の直後にある <p>）
~	一般兄弟セレクター。指定要素の後にある、同じ親を持つすべての兄弟要素を指定します。	h2 ~ p （<h2>の後にある、すべての <p>）
属性・擬似クラスによる指定
指定方法	説明	例
[attribute='value']	属性値が一致する要素。	input[type='submit']
[attribute*='value']	属性値に特定の文字列を含む要素。	a[href*='download']
:nth-child(n)	n番目の子要素を指定します。	ul li:nth-child(3) （3番目の <li>）
:last-child	最後の子要素を指定します。	ul li:last-child （最後の <li>）
Seleniumでの活用例
最後に、実際のコードでどのようにセレクターを使い分けるかを見てみましょう。find_element()やfind_elements()を使って要素を特定します。
python
from selenium import webdriver
from selenium.webdriver.common.by import By

# WebDriverの初期化
driver = webdriver.Chrome()
driver.get("https://example.com")

# 1. CSSセレクターで高速に親要素を取得
parent_element = driver.find_element(By.CSS_SELECTOR, "#main-content > .post")

# 2. 取得した親要素を起点に、XPathでテキスト指定して子要素を特定
#    より狭い範囲で検索するため、パフォーマンスが向上する
title_element = parent_element.find_element(By.XPATH, ".//h2[text()='記事タイトル']")

print(title_element.text)

# WebDriverを閉じる
driver.quit()
コードは注意してご使用ください。

この例では、最初に大きな範囲をCSSセレクターで絞り込み、次にXPathのテキスト指定でピンポイントの要素を特定しています。このように両者を組み合わせることで、堅牢かつ効率的なスクレイピングコードを書くことができます。
参考情報
WebScrapingAPI: https://www.webscrapingapi.com/the-ultimate-xpath-cheat-sheet
BrowserStack: https://www.browserstack.com/guide/css-selectors-cheat-sheet
この記事が、あなたのWebスクレイピングの効率アップに役立つことを願っています。
